<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MÖBIUS LAB | Interactive Topology Simulation</title>
    <style>
        :root {
            --bg-color: #050507;
            --accent-color: #00f3ff;
            --ui-font: 'Courier New', Courier, monospace;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: var(--ui-font);
            color: #ccc;
            user-select: none;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* Cinematic UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            background: radial-gradient(circle at center, transparent 50%, #000000 120%);
        }

        #title-block {
            position: absolute;
            top: 30px;
            left: 40px;
            pointer-events: auto;
            opacity: 0; /* Animated via JS */
        }

        h1 {
            font-size: 14px;
            letter-spacing: 4px;
            margin: 0;
            color: var(--accent-color);
            text-transform: uppercase;
            text-shadow: 0 0 10px rgba(0, 243, 255, 0.5);
        }

        .subtitle {
            font-size: 10px;
            color: #666;
            margin-top: 5px;
            letter-spacing: 1px;
        }

        #controls-hint {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 11px;
            color: rgba(255, 255, 255, 0.5);
            text-align: center;
            opacity: 0;
            transition: opacity 1s ease;
        }
        
        .key {
            color: var(--accent-color);
            font-weight: bold;
        }

        /* Custom dat.GUI styling */
        .dg.ac {
            z-index: 20 !important;
        }
        .dg.main {
            border-radius: 0 !important;
            box-shadow: 0 0 20px rgba(0,0,0,0.5) !important;
        }
        .dg .c .slider-fg {
            background: var(--accent-color) !important;
            box-shadow: 0 0 5px var(--accent-color);
        }
        .dg .cr.function .property-name {
            width: 100%;
        }
    </style>
</head>
<body>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div id="title-block">
            <h1>Möbius Lab</h1>
            <div class="subtitle">TOPOLOGY RESEARCH UNIT v.2.5</div>
        </div>
        <div id="controls-hint">
            <span class="key">DRAG</span> TO ROTATE &nbsp;|&nbsp; <span class="key">SCROLL</span> TO ZOOM &nbsp;|&nbsp; USE PANEL FOR PHYSICS
        </div>
    </div>

    <!-- Import Maps for Three.js and Addons -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <!-- Main Application Script -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
        import TWEEN from 'three/addons/libs/tween.module.js';

        // --- CONFIGURATION & STATE ---
        const CONFIG = {
            twist: 1,           // Half-twists (1 = Möbius strip)
            width: 1.5,
            radius: 5,
            detailU: 300,       // High detail for smooth curves
            detailV: 20,        // Width segments
            antSpeed: 0.005,
            bloomStrength: 1.2,
            bloomThreshold: 0.1,
            bloomRadius: 0.5,
            autoRotate: false,
            showWireframe: false
        };

        const STATE = {
            time: 0,
            antU: 0, // Parametric position of ant
            antSide: 1 // 1 or -1 to handle flipping
        };

        // --- SCENE SETUP ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050507);
        scene.fog = new THREE.FogExp2(0x050507, 0.035);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(8, 6, 12);

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxDistance = 30;

        // --- LIGHTING ---
        const ambientLight = new THREE.AmbientLight(0x404040, 2); // Soft base
        scene.add(ambientLight);

        // Key Light (Blue/Cyan hint)
        const keyLight = new THREE.DirectionalLight(0x88ccff, 3);
        keyLight.position.set(10, 10, 5);
        keyLight.castShadow = true;
        scene.add(keyLight);

        // Rim Light (Magenta/Purple hint for drama)
        const rimLight = new THREE.SpotLight(0xff00aa, 10);
        rimLight.position.set(-10, 0, -5);
        rimLight.lookAt(0,0,0);
        scene.add(rimLight);

        // --- MÖBIUS GENERATOR ---
        
        let mobiusMesh, wireMesh;
        const mobiusMaterial = new THREE.MeshPhysicalMaterial({
            color: 0x1a1a1a,
            metalness: 0.9,
            roughness: 0.2,
            clearcoat: 1.0,
            clearcoatRoughness: 0.1,
            side: THREE.DoubleSide,
            flatShading: false
        });

        // Neon Edge Material
        const lineMaterial = new THREE.LineBasicMaterial({ 
            color: 0x00f3ff, 
            transparent: true, 
            opacity: 0.8,
            blending: THREE.AdditiveBlending
        });

        function getMobiusPoint(u, v, target, twist, radius, width) {
            // u: 0 -> 2PI, v: -1 -> 1
            // twist is number of HALF twists
            const alpha = u; 
            const phi = (twist * u) / 2.0;

            // Mobius parametric equations
            const x = (radius + width * v * Math.cos(phi)) * Math.cos(alpha);
            const y = width * v * Math.sin(phi); // Y-up orientation logic
            const z = (radius + width * v * Math.cos(phi)) * Math.sin(alpha);

            // Rotate to lay flat on XZ plane primarily, looks better
            target.set(x, z, y); 
        }

        function createMobiusStrip() {
            if (mobiusMesh) {
                mobiusMesh.geometry.dispose();
                scene.remove(mobiusMesh);
                scene.remove(wireMesh);
            }

            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const normals = [];
            const indices = [];
            const uvs = [];
            const edgeVertices = []; // For the neon rim

            const uSegs = CONFIG.detailU;
            const vSegs = CONFIG.detailV;

            // Generate vertices
            for (let i = 0; i <= uSegs; i++) {
                const u = (i / uSegs) * Math.PI * 2;
                
                for (let j = 0; j <= vSegs; j++) {
                    const v = (j / vSegs) * 2 - 1; // -1 to 1

                    const p = new THREE.Vector3();
                    getMobiusPoint(u, v, p, CONFIG.twist, CONFIG.radius, CONFIG.width);
                    vertices.push(p.x, p.y, p.z);
                    uvs.push(i / uSegs, j / vSegs);

                    // Collect edge points (top and bottom rim)
                    if (j === 0 || j === vSegs) {
                        edgeVertices.push(p.x, p.y, p.z);
                    }
                }
            }

            // Generate Indices
            for (let i = 0; i < uSegs; i++) {
                for (let j = 0; j < vSegs; j++) {
                    const a = i * (vSegs + 1) + j;
                    const b = (i + 1) * (vSegs + 1) + j;
                    const c = (i + 1) * (vSegs + 1) + (j + 1);
                    const d = i * (vSegs + 1) + (j + 1);

                    // Two triangles per quad
                    indices.push(a, b, d);
                    indices.push(b, c, d);
                }
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
            geometry.setIndex(indices);
            geometry.computeVertexNormals();

            // Create Main Mesh
            mobiusMesh = new THREE.Mesh(geometry, mobiusMaterial);
            scene.add(mobiusMesh);

            // Create Neon Edges (Separate Line Loop)
            // Need to organize edge vertices correctly to form loops
            // Top edge is j=0, Bottom edge is j=vSegs
            const rimGeometry = new THREE.BufferGeometry();
            // We need to re-sort edges to make continuous lines. 
            // Simple approach: One line for v=-1, one for v=1
            const line1 = [];
            const line2 = [];
            
            for(let i=0; i<=uSegs; i++) {
                const u = (i / uSegs) * Math.PI * 2;
                const p1 = new THREE.Vector3();
                const p2 = new THREE.Vector3();
                getMobiusPoint(u, -1, p1, CONFIG.twist, CONFIG.radius, CONFIG.width);
                getMobiusPoint(u, 1, p2, CONFIG.twist, CONFIG.radius, CONFIG.width);
                line1.push(p1.x, p1.y, p1.z);
                line2.push(p2.x, p2.y, p2.z);
            }
            
            rimGeometry.setAttribute('position', new THREE.Float32BufferAttribute([...line1, ...line2], 3));
            wireMesh = new THREE.LineSegments(rimGeometry, lineMaterial);
            scene.add(wireMesh);
        }

        // --- THE ANT (CYBER-ANT) ---
        class CyberAnt {
            constructor() {
                this.mesh = new THREE.Group();
                this.raycaster = new THREE.Raycaster();
                this.downVector = new THREE.Vector3(0, -1, 0);
                this.trailPoints = [];
                this.trailGeometry = new THREE.BufferGeometry();
                this.trailMesh = new THREE.Line(this.trailGeometry, new THREE.LineBasicMaterial({
                    color: 0xffaa00,
                    transparent: true,
                    opacity: 0.6,
                    blending: THREE.AdditiveBlending
                }));
                scene.add(this.trailMesh);
                
                this.buildModel();
            }

            buildModel() {
                const matBody = new THREE.MeshStandardMaterial({ 
                    color: 0xF4E4C1, // Sand/Ivory
                    roughness: 0.4, 
                    metalness: 0.5 
                });
                const matJoints = new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.8 });
                const matGlow = new THREE.MeshBasicMaterial({ color: 0xffaa00 });

                // Segment 1: Head
                const head = new THREE.Mesh(new THREE.DodecahedronGeometry(0.15), matBody);
                
                // Segment 2: Thorax
                const thorax = new THREE.Mesh(new THREE.CapsuleGeometry(0.12, 0.25, 4, 8), matBody);
                thorax.rotation.x = Math.PI / 2;
                thorax.position.z = 0.3;

                // Segment 3: Abdomen
                const abdomen = new THREE.Mesh(new THREE.CapsuleGeometry(0.2, 0.4, 4, 8), matBody);
                abdomen.rotation.x = Math.PI / 2;
                abdomen.position.z = 0.7;
                
                // Glowing Spine
                const spine = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.05, 0.8), matGlow);
                spine.position.z = 0.4;
                spine.position.y = 0.12;

                this.mesh.add(head, thorax, abdomen, spine);

                // Legs (Procedural low poly)
                this.legs = [];
                for(let i=0; i<6; i++) {
                    const legGroup = new THREE.Group();
                    const legGeo = new THREE.BoxGeometry(0.04, 0.4, 0.04);
                    // Upper leg
                    const upper = new THREE.Mesh(legGeo, matJoints);
                    upper.position.y = -0.2;
                    upper.rotation.x = 0.5;
                    // Lower leg
                    const lower = new THREE.Mesh(legGeo, matBody);
                    lower.position.y = -0.4; // relative to upper
                    lower.rotation.x = -1.2;
                    upper.add(lower);
                    
                    legGroup.add(upper);
                    
                    const side = i % 2 === 0 ? 1 : -1;
                    const posZ = 0.1 + Math.floor(i/2) * 0.25;
                    
                    legGroup.position.set(side * 0.15, 0, posZ);
                    legGroup.rotation.z = side * 0.5;
                    
                    this.mesh.add(legGroup);
                    this.legs.push({ mesh: legGroup, side: side, index: i });
                }

                scene.add(this.mesh);
            }

            animateLegs(speed) {
                const time = Date.now() * 0.015;
                this.legs.forEach(leg => {
                    // Tripod gait math
                    const offset = leg.index % 2 === 0 ? 0 : Math.PI;
                    const phase = (Math.floor(leg.index/2) % 2 === 0) ? 0 : Math.PI;
                    
                    const rot = Math.sin(time * 2 + offset + phase) * 0.3 * (speed * 100);
                    leg.mesh.rotation.x = rot;
                    
                    // Bobbing
                    leg.mesh.position.y = Math.abs(Math.sin(time * 2 + offset)) * 0.05;
                });
            }

            update(u) {
                // Calculate position on strip based on U
                // U goes from 0 to 2PI. But Mobius is single-sided 4PI loop essentially.
                // We use modulo to keep it safe.
                
                const safeU = u % (Math.PI * 4); // Full traversal of both 'sides'
                const effectiveU = safeU % (Math.PI * 2); 
                
                // Determine V (center)
                const v = 0;

                // 1. Get Position
                const pos = new THREE.Vector3();
                getMobiusPoint(effectiveU, v, pos, CONFIG.twist, CONFIG.radius, CONFIG.width);

                // 2. Get Orientation (Normal & Tangent)
                // Tangent: deriv wrt u
                const delta = 0.01;
                const nextPos = new THREE.Vector3();
                getMobiusPoint(effectiveU + delta, v, nextPos, CONFIG.twist, CONFIG.radius, CONFIG.width);
                const tangent = nextPos.clone().sub(pos).normalize();

                // Binormal: deriv wrt v
                const sidePos = new THREE.Vector3();
                getMobiusPoint(effectiveU, v + delta, sidePos, CONFIG.twist, CONFIG.radius, CONFIG.width);
                const binormal = sidePos.clone().sub(pos).normalize();

                // Normal
                const normal = new THREE.Vector3().crossVectors(tangent, binormal).normalize();

                // Handle the "Twist" flip
                // If the Mobius strip twists an odd number of times, the normal flips.
                // We check against the mesh actual normals using Raycaster to ensure perfect alignment.
                
                const rayOrigin = pos.clone().add(normal.clone().multiplyScalar(2));
                this.raycaster.set(rayOrigin, normal.clone().negate());
                const intersects = this.raycaster.intersectObject(mobiusMesh);

                if (intersects.length > 0) {
                    const hit = intersects[0];
                    this.mesh.position.copy(hit.point);
                    
                    // Align Up vector to hit normal
                    const targetUp = hit.face.normal.clone().transformDirection(mobiusMesh.matrixWorld);
                    
                    // Smooth transition for rotation
                    const qTarget = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), targetUp);
                    
                    // Look At tangent
                    const lookPos = hit.point.clone().add(tangent);
                    this.mesh.lookAt(lookPos);
                    
                    // Apply Up correction (Quaternion math to preserve lookAt while fixing Up)
                    // Simplified: We just construct a matrix from basis vectors
                    const m = new THREE.Matrix4();
                    const zAxis = tangent.clone().normalize();
                    const yAxis = targetUp.clone().normalize();
                    const xAxis = new THREE.Vector3().crossVectors(yAxis, zAxis).normalize();
                    m.makeBasis(xAxis, yAxis, zAxis);
                    this.mesh.setRotationFromMatrix(m);

                    // Add slight offset so feet touch ground
                    this.mesh.position.add(targetUp.multiplyScalar(0.2));
                } else {
                    // Fallback to math-only if raycast fails (rare)
                    this.mesh.position.copy(pos);
                    // ... basic alignment fallback
                }

                // Animate Legs
                this.animateLegs(CONFIG.antSpeed);
                
                // Trail Logic
                this.updateTrail(this.mesh.position);
            }

            updateTrail(pos) {
                this.trailPoints.push(pos.clone());
                if(this.trailPoints.length > 150) this.trailPoints.shift();

                const positions = new Float32Array(this.trailPoints.length * 3);
                for(let i=0; i<this.trailPoints.length; i++) {
                    positions[i*3] = this.trailPoints[i].x;
                    positions[i*3+1] = this.trailPoints[i].y;
                    positions[i*3+2] = this.trailPoints[i].z;
                }
                this.trailGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                this.trailGeometry.setDrawRange(0, this.trailPoints.length);
            }
        }

        // --- BACKGROUND & PARTICLES ---
        function createStars() {
            const starGeo = new THREE.BufferGeometry();
            const count = 2000;
            const pos = new Float32Array(count * 3);
            for(let i=0; i<count * 3; i++) {
                pos[i] = (Math.random() - 0.5) * 60;
            }
            starGeo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            const starMat = new THREE.PointsMaterial({
                color: 0x888888,
                size: 0.05,
                transparent: true,
                opacity: 0.6
            });
            const stars = new THREE.Points(starGeo, starMat);
            scene.add(stars);
        }

        // --- POST PROCESSING ---
        const composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);

        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = CONFIG.bloomThreshold;
        bloomPass.strength = CONFIG.bloomStrength;
        bloomPass.radius = CONFIG.bloomRadius;
        composer.addPass(bloomPass);

        // Film Grain / Noise Shader for "Dark Matter" feel
        const FilmGrainShader = {
            uniforms: {
                "tDiffuse": { value: null },
                "amount": { value: 0.05 },
                "time": { value: 0.0 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                }
            `,
            fragmentShader: `
                uniform float amount;
                uniform float time;
                uniform sampler2D tDiffuse;
                varying vec2 vUv;
                
                float random( vec2 p ) {
                    vec2 K1 = vec2(
                        23.14069263277926, // e^pi (Gelfond's constant)
                        2.665144142690225 // 2^sqrt(2) (Gelfond–Schneider constant)
                    );
                    return fract( cos( dot(p,K1) ) * 12345.6789 );
                }

                void main() {
                    vec4 color = texture2D( tDiffuse, vUv );
                    vec2 uvRandom = vUv;
                    uvRandom.y *= random(vec2(uvRandom.y, time));
                    color.rgb += random( vUv + time ) * amount;
                    gl_FragColor = vec4( color.rgb, color.a );
                }
            `
        };

        const grainPass = new ShaderPass(FilmGrainShader);
        grainPass.renderToScreen = true;
        composer.addPass(grainPass);


        // --- INIT & EVENTS ---
        createMobiusStrip();
        createStars();
        const ant = new CyberAnt();

        // UI & Tweens
        const gui = new GUI({ width: 300 });
        const folderGeo = gui.addFolder('GEOMETRY');
        folderGeo.add(CONFIG, 'twist', 0, 5.5, 0.5).name('Twist Factor').onChange(createMobiusStrip);
        folderGeo.add(CONFIG, 'width', 0.5, 3).name('Ribbon Width').onChange(createMobiusStrip);
        
        const folderSim = gui.addFolder('SIMULATION');
        folderSim.add(CONFIG, 'antSpeed', 0.001, 0.03).name('Ant Speed');
        folderSim.add(CONFIG, 'autoRotate').name('Auto Rotate Cam');
        
        const folderVis = gui.addFolder('VISUALS');
        folderVis.add(CONFIG, 'bloomStrength', 0, 3).onChange(v => bloomPass.strength = v);
        folderVis.add(mobiusMaterial, 'roughness', 0, 1);
        folderVis.add(mobiusMaterial, 'metalness', 0, 1);
        
        // Intro Animation
        window.onload = () => {
            const title = document.getElementById('title-block');
            const hint = document.getElementById('controls-hint');
            
            // Fade In UI
            setTimeout(() => title.style.opacity = '1', 500);
            setTimeout(() => hint.style.opacity = '1', 1500);
            setTimeout(() => hint.style.opacity = '0', 6000); // Hide hint later

            // Camera Fly-in
            new TWEEN.Tween(camera.position)
                .to({ x: 6, y: 5, z: 8 }, 2000)
                .easing(TWEEN.Easing.Cubic.Out)
                .start();
        };

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- MAIN LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            const dt = 0.016;
            STATE.time += dt;
            
            // Update Ant
            STATE.antU += CONFIG.antSpeed;
            ant.update(STATE.antU);

            // Update Shader Time
            grainPass.uniforms['time'].value = STATE.time;

            // Auto Rotate
            if (CONFIG.autoRotate) {
                scene.rotation.y += 0.002;
            }

            controls.update();
            TWEEN.update();
            
            // Render
            composer.render();
        }

        animate();

    </script>
</body>
</html>
