<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Realistic Mobius Ant</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; display: flex; justify-content: center; align-items: center;
            color: #8B4513; font-size: 20px; z-index: 999; transition: opacity 0.5s;
        }
        .dg.ac { z-index: 100 !important; }
    </style>
    <!-- Import Map for Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

<div id="loader">Генерация органической формы жизни...</div>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';

    // --- CONFIGURATION ---
    const PARAMS = {
        radius: 7,
        width: 3,
        twists: 1, 
        segments: 200, 
        widthSegments: 40, // High detail for raycasting accuracy
        antSpeed: 1.0,
        bloomStrength: 0.5,
        showWireframe: false
    };

    // --- GLOBALS ---
    let scene, camera, renderer, composer, controls;
    let mobiusMesh;
    let ant; // Ant Instance
    let clock = new THREE.Clock();
    
    init();
    animate();

    function init() {
        const container = document.createElement('div');
        document.body.appendChild(container);

        // 1. Scene & Camera
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.015);

        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(10, 12, 16);

        // 2. Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ReinhardToneMapping;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        // 3. Controls
        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.maxDistance = 60;

        // 4. Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 3);
        scene.add(ambientLight);

        const spotLight = new THREE.SpotLight(0xffffff, 50);
        spotLight.position.set(15, 20, 10);
        spotLight.angle = 0.5;
        spotLight.penumbra = 0.5;
        spotLight.castShadow = true;
        spotLight.shadow.mapSize.width = 2048;
        spotLight.shadow.mapSize.height = 2048;
        scene.add(spotLight);

        const blueRimLight = new THREE.PointLight(0x0088ff, 3, 20);
        blueRimLight.position.set(-10, -5, -10);
        scene.add(blueRimLight);

        // 5. Objects
        createEnvironment();
        createMobiusStrip();
        
        // Init Ant
        ant = new Ant(scene);

        // 6. Post-Processing
        const renderPass = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.2;
        bloomPass.strength = PARAMS.bloomStrength;
        bloomPass.radius = 0.5;
        
        composer = new EffectComposer(renderer);
        composer.addPass(renderPass);
        composer.addPass(bloomPass);

        // 7. GUI
        setupGUI();
        
        document.getElementById('loader').style.opacity = 0;
        setTimeout(() => document.getElementById('loader').remove(), 500);
        window.addEventListener('resize', onWindowResize);
    }

    // --- MATH & GEOMETRY ---

    function getMobiusData(u, v, targetPos, targetNorm) {
        const R = PARAMS.radius;
        const w = PARAMS.width / 2;
        const alpha = (PARAMS.twists * u) / 2;

        const x = (R + w * v * Math.cos(alpha)) * Math.cos(u);
        const y = (R + w * v * Math.cos(alpha)) * Math.sin(u);
        const z = w * v * Math.sin(alpha);

        // Position (swap Y/Z for horizontal orientation)
        targetPos.set(x, z, y);

        if (targetNorm) {
            // Analytical normal (approximate)
            const du = 0.01; 
            const dv = 0.1;
            
            const pU = new THREE.Vector3();
            const pV = new THREE.Vector3();
            
            // Calc neighbor U
            let alphaU = (PARAMS.twists * (u + du)) / 2;
            let xU = (R + w * v * Math.cos(alphaU)) * Math.cos(u + du);
            let yU = (R + w * v * Math.cos(alphaU)) * Math.sin(u + du);
            let zU = w * v * Math.sin(alphaU);
            pU.set(xU, zU, yU);

            // Calc neighbor V
            let alphaV = (PARAMS.twists * u) / 2;
            let xV = (R + w * (v + dv) * Math.cos(alphaV)) * Math.cos(u);
            let yV = (R + w * (v + dv) * Math.cos(alphaV)) * Math.sin(u);
            let zV = w * (v + dv) * Math.sin(alphaV);
            pV.set(xV, zV, yV);

            const tangent = new THREE.Vector3().subVectors(pU, targetPos).normalize();
            const bitangent = new THREE.Vector3().subVectors(pV, targetPos).normalize();
            targetNorm.crossVectors(tangent, bitangent).normalize();
        }
    }

    function createMobiusStrip() {
        if (mobiusMesh) {
            scene.remove(mobiusMesh);
            mobiusMesh.geometry.dispose();
        }

        const geometry = new THREE.BufferGeometry();
        const vertices = [];
        const colors = [];
        const indices = [];

        const uSeg = PARAMS.segments;
        const vSeg = PARAMS.widthSegments;
        const c1 = new THREE.Color(0x000510);
        const c2 = new THREE.Color(0x003344);

        for (let i = 0; i <= uSeg; i++) {
            const u = (i / uSeg) * Math.PI * 2;
            for (let j = 0; j <= vSeg; j++) {
                const v = (j / vSeg) * 2 - 1;
                const p = new THREE.Vector3();
                getMobiusData(u, v, p, null);
                vertices.push(p.x, p.y, p.z);

                // Grid pattern coloring
                const isGrid = (i % 10 === 0 || j === 0 || j === vSeg);
                const col = isGrid ? new THREE.Color(0x00aaff) : c1.clone().lerp(c2, Math.abs(v));
                colors.push(col.r, col.g, col.b);
            }
        }

        for (let i = 0; i < uSeg; i++) {
            for (let j = 0; j < vSeg; j++) {
                const a = i * (vSeg + 1) + j;
                const b = (i + 1) * (vSeg + 1) + j;
                const c = (i + 1) * (vSeg + 1) + (j + 1);
                const d = i * (vSeg + 1) + (j + 1);
                indices.push(a, b, d, b, c, d);
            }
        }

        geometry.setIndex(indices);
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        geometry.computeVertexNormals();

        const material = new THREE.MeshStandardMaterial({
            vertexColors: true,
            roughness: 0.4,
            metalness: 0.6,
            side: THREE.DoubleSide,
            wireframe: PARAMS.showWireframe
        });

        mobiusMesh = new THREE.Mesh(geometry, material);
        mobiusMesh.receiveShadow = true;
        scene.add(mobiusMesh);
    }

    // --- ANT CLASS (The Core Logic) ---

    class Ant {
        constructor(scene) {
            this.scene = scene;
            this.group = new THREE.Group();
            
            // Animation State
            this.u = 0;
            this.v = 0;
            this.speed = 0;
            this.raycaster = new THREE.Raycaster();
            this.rayDown = new THREE.Vector3();
            
            // Body Parts references
            this.legs = []; // { pivot1, pivot2, pivot3, side, offset }
            this.antennae = [];
            this.thorax = null;
            this.head = null;
            this.abdomen = null;

            this.createModel();
            this.scene.add(this.group);
        }

        createModel() {
            // Materials
            const shellMat = new THREE.MeshStandardMaterial({
                color: 0x8B4513, // Saddle Brown
                roughness: 0.3,
                metalness: 0.1,
            });
            const eyeMat = new THREE.MeshPhongMaterial({
                color: 0x050505,
                specular: 0xffffff,
                shininess: 100
            });
            const legMat = new THREE.MeshStandardMaterial({
                color: 0x5C3317, // Darker brown
                roughness: 0.5
            });

            // 1. Thorax (Center)
            const thoraxGeo = new THREE.SphereGeometry(0.25, 16, 16);
            thoraxGeo.scale(1, 0.8, 1);
            this.thorax = new THREE.Mesh(thoraxGeo, shellMat);
            this.thorax.castShadow = true;
            this.group.add(this.thorax);

            // 2. Head
            const headGeo = new THREE.SphereGeometry(0.2, 16, 16);
            headGeo.scale(1, 0.8, 1.1);
            this.head = new THREE.Mesh(headGeo, shellMat);
            this.head.position.set(0, 0.1, 0.4); // Forward and up
            this.head.castShadow = true;
            this.thorax.add(this.head);

            // Eyes
            const eyeGeo = new THREE.SphereGeometry(0.06, 8, 8);
            const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
            leftEye.position.set(0.12, 0.05, 0.1);
            const rightEye = leftEye.clone();
            rightEye.position.set(-0.12, 0.05, 0.1);
            this.head.add(leftEye, rightEye);

            // Antennae (Curve)
            const curve = new THREE.CatmullRomCurve3([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(0.05, 0.2, 0.1),
                new THREE.Vector3(0.15, 0.3, 0.2)
            ]);
            const antGeo = new THREE.TubeGeometry(curve, 8, 0.015, 4, false);
            const antMat = new THREE.MeshStandardMaterial({ color: 0xA0522D }); // Lighter brown
            
            const leftAnt = new THREE.Mesh(antGeo, antMat);
            leftAnt.position.set(0.08, 0.1, 0.15);
            this.head.add(leftAnt);
            this.antennae.push({ mesh: leftAnt, baseRot: {x:0, y:0, z:0}, phase: 0 });

            const rightAnt = leftAnt.clone();
            rightAnt.scale.x = -1; // Mirror
            rightAnt.position.set(-0.08, 0.1, 0.15);
            this.head.add(rightAnt);
            this.antennae.push({ mesh: rightAnt, baseRot: {x:0, y:0, z:0}, phase: Math.PI });


            // 3. Abdomen (Back)
            const abGeo = new THREE.SphereGeometry(0.35, 16, 16);
            abGeo.scale(1, 0.9, 1.4);
            this.abdomen = new THREE.Mesh(abGeo, shellMat);
            this.abdomen.position.set(0, 0.05, -0.55);
            this.abdomen.castShadow = true;
            this.thorax.add(this.abdomen);

            // 4. Legs (3 pairs, 3 segments each)
            const legPos = [0.15, 0, -0.2]; // Z positions on thorax
            
            for(let i=0; i<3; i++) {
                this.createLeg(legMat, 1, legPos[i], i); // Left
                this.createLeg(legMat, -1, legPos[i], i); // Right
            }
        }

        createLeg(material, side, zPos, index) {
            // Hierarchy: Pivot -> Coxa -> Femur -> Tibia
            
            // Pivot on Thorax
            const pivot = new THREE.Group();
            pivot.position.set(side * 0.15, -0.05, zPos);
            // Rotate base slightly to fan out legs
            const fanAngle = (index - 1) * 0.4; 
            pivot.rotation.y = fanAngle * side; 
            this.thorax.add(pivot);

            // Coxa (Hip) - Short
            const coxaGeo = new THREE.CapsuleGeometry(0.04, 0.1, 4, 8);
            const coxa = new THREE.Mesh(coxaGeo, material);
            coxa.rotation.z = side * Math.PI / 3;
            coxa.position.x = side * 0.05;
            pivot.add(coxa);

            // Femur (Thigh) - Long, goes up
            const femurGroup = new THREE.Group();
            femurGroup.position.set(0, 0.05, 0); // End of Coxa
            coxa.add(femurGroup);

            const femurGeo = new THREE.CapsuleGeometry(0.035, 0.35, 4, 8);
            const femur = new THREE.Mesh(femurGeo, material);
            femur.position.y = 0.175; // Center of geometry
            femurGroup.rotation.z = side * 1.0; // Angle up
            femurGroup.add(femur);

            // Tibia (Shin) - Long, goes down
            const tibiaGroup = new THREE.Group();
            tibiaGroup.position.set(0, 0.35, 0); // End of Femur
            femur.add(tibiaGroup);

            const tibiaGeo = new THREE.CapsuleGeometry(0.025, 0.4, 4, 8);
            const tibia = new THREE.Mesh(tibiaGeo, material);
            tibia.position.y = -0.2; // Hang down
            tibiaGroup.rotation.z = side * -2.2; // Angle down sharply
            tibiaGroup.add(tibia);

            this.legs.push({
                root: pivot,
                coxa: coxa,
                femur: femurGroup,
                tibia: tibiaGroup,
                side: side,
                index: index,
                baseRotY: pivot.rotation.y,
                baseFemurZ: femurGroup.rotation.z,
                baseTibiaZ: tibiaGroup.rotation.z
            });
        }

        update(time, delta) {
            this.speed = PARAMS.antSpeed;
            this.u += this.speed * delta * 0.5;

            // --- 1. PHYSICS & RAYCASTING ---
            
            // Step A: Get ideal Mathematical position & normal
            const idealPos = new THREE.Vector3();
            const idealNorm = new THREE.Vector3();
            getMobiusData(this.u, this.v, idealPos, idealNorm);

            // Step B: Prepare Raycaster
            // We start "above" the surface (along normal) and shoot down
            const rayOrigin = idealPos.clone().add(idealNorm.clone().multiplyScalar(1.5));
            const rayDir = idealNorm.clone().negate(); // Down

            this.raycaster.set(rayOrigin, rayDir);
            
            // Intersect with Mobius Mesh
            // Note: raycaster can be CPU heavy. We optimized geometry segments.
            const intersects = this.raycaster.intersectObject(mobiusMesh);

            if (intersects.length > 0) {
                const hit = intersects[0];
                
                // Set position exactly on the face
                this.group.position.copy(hit.point);

                // For orientation, we blend the mathematical normal (smooth) 
                // with the face normal (accurate but faceted)
                // Using mathematical normal for Up vector usually looks smoother for walking
                const up = idealNorm;
                
                // Calculate Forward vector (Tangent)
                const nextPos = new THREE.Vector3();
                getMobiusData(this.u + 0.05, this.v, nextPos, null);
                
                // Project nextPos onto the plane defined by 'up' to ensure orthogonality
                const forward = new THREE.Vector3().subVectors(nextPos, hit.point).normalize();
                
                // Matrix construction
                const m = new THREE.Matrix4();
                const right = new THREE.Vector3().crossVectors(up, forward).normalize();
                const correctedForward = new THREE.Vector3().crossVectors(right, up).normalize();
                
                m.makeBasis(right, up, correctedForward.negate()); // Negate forward because model faces +Z or -Z depending
                this.group.quaternion.setFromRotationMatrix(m);
                
                // Correct model orientation (if ant was built facing Z, align it)
                this.group.rotateY(Math.PI); 

            } else {
                // Fallback if raycast fails (e.g. edge cases)
                this.group.position.copy(idealPos);
                // Simple orientation
                const lookAtPos = new THREE.Vector3();
                getMobiusData(this.u + 0.1, this.v, lookAtPos, null);
                this.group.lookAt(lookAtPos);
            }

            // --- 2. ORGANIC ANIMATION ---

            if (this.speed > 0) {
                const walkCycle = time * this.speed * 15;
                
                // A. Body Sway
                this.thorax.rotation.z = Math.sin(walkCycle) * 0.05; // Roll
                this.thorax.rotation.y = Math.cos(walkCycle * 0.5) * 0.05; // Yaw
                this.head.rotation.x = Math.sin(walkCycle * 2) * 0.05 - 0.2; // Bobbing
                this.abdomen.rotation.x = Math.sin(walkCycle * 2 + Math.PI) * 0.05;

                // B. Leg Movement (Inverse Kinematics approximation via FK)
                this.legs.forEach(leg => {
                    // Tripod Gait: Legs 0,2 on left move with 1 on right
                    const isTripodA = (leg.index % 2 === 0 && leg.side === 1) || (leg.index % 2 !== 0 && leg.side === -1);
                    const phase = isTripodA ? 0 : Math.PI;
                    
                    const cycle = walkCycle + phase;
                    
                    // 1. Swing (Forward/Back) - Coxa
                    const swingAmp = 0.5; 
                    leg.root.rotation.y = leg.baseRotY + Math.sin(cycle) * swingAmp * leg.side;

                    // 2. Lift (Up/Down) - Femur
                    // Lift happens when leg moves forward (sin > 0)
                    const liftVal = Math.max(0, Math.sin(cycle));
                    const liftAmp = 0.6;
                    leg.femur.rotation.z = leg.baseFemurZ + (liftVal * liftAmp * leg.side);

                    // 3. Reach/Contract - Tibia
                    // Leg extends when on ground, flexes when lifted
                    leg.tibia.rotation.z = leg.baseTibiaZ + (liftVal * 1.5 * leg.side);
                });

                // C. Antennae Wiggle
                this.antennae.forEach(ant => {
                    const noise = Math.sin(time * 10 + ant.phase);
                    ant.mesh.rotation.z = noise * 0.1;
                    ant.mesh.rotation.x = Math.cos(time * 8) * 0.05;
                });
            }
        }
    }

    // --- ENVIRONMENT ---
    function createEnvironment() {
        const geo = new THREE.PlaneGeometry(100, 100);
        const mat = new THREE.ShadowMaterial({ opacity: 0.5 });
        const plane = new THREE.Mesh(geo, mat);
        plane.rotation.x = -Math.PI / 2;
        plane.position.y = -8;
        plane.receiveShadow = true;
        scene.add(plane);

        // Stars
        const starGeo = new THREE.BufferGeometry();
        const starCount = 1000;
        const starPos = [];
        for(let i=0; i<starCount; i++) {
            starPos.push((Math.random()-0.5)*100, (Math.random()-0.5)*100, (Math.random()-0.5)*100);
        }
        starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
        const starMat = new THREE.PointsMaterial({color: 0xffffff, size: 0.1});
        scene.add(new THREE.Points(starGeo, starMat));
    }

    // --- UI ---
    function setupGUI() {
        const gui = new GUI();
        const folder = gui.addFolder('Parameters');
        
        folder.add(PARAMS, 'twists', 0, 4, 0.1).name('Twists').onChange(createMobiusStrip);
        folder.add(PARAMS, 'width', 1, 5).name('Width').onChange(createMobiusStrip);
        folder.add(PARAMS, 'radius', 4, 10).name('Radius').onChange(createMobiusStrip);
        folder.add(PARAMS, 'antSpeed', 0, 3).name('Ant Speed');
        folder.add(PARAMS, 'bloomStrength', 0, 2).name('Glow').onChange(v => composer.passes[1].strength = v);
        folder.add(PARAMS, 'showWireframe').name('Wireframe').onChange(createMobiusStrip);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);
        const delta = clock.getDelta();
        const time = clock.getElapsedTime();

        if (ant) ant.update(time, delta);
        controls.update();

        composer.render();
    }
</script>
</body>
</html>
