<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mobius Explorer 2.0: Cinematic Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        
        /* Loading overlay */
        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; display: flex; justify-content: center; align-items: center;
            color: #00ffff; font-size: 20px; z-index: 999; transition: opacity 0.5s;
        }

        /* Custom GUI adjustments */
        .dg.ac { z-index: 100 !important; }
        .dg .c .slider { background: #1a1a1a !important; }
        .dg .c .slider-fg { background: #00ffff !important; }
        .dg.main.a { border-radius: 8px; overflow: hidden; box-shadow: 0 0 20px rgba(0, 255, 255, 0.2); }
    </style>
    
    <!-- Import Maps for cleaner module loading (Modern Standard) -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

<div id="loader">Инициализация квантового поля...</div>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

    // --- CONFIGURATION ---
    const PARAMS = {
        radius: 6,
        width: 2.5,
        twists: 1.0, // 0 = cylinder, 1 = mobius
        segments: 200, // Length detail
        widthSegments: 30, // Width detail
        antSpeed: 1.5,
        bloomStrength: 0.8,
        bloomRadius: 0.5,
        bloomThreshold: 0.2,
        showWireframe: false,
        themeColor: '#00ccff'
    };

    // --- GLOBALS ---
    let scene, camera, renderer, composer, controls;
    let mobiusMesh, antMesh, trailLine;
    let clock = new THREE.Clock();
    let time = 0;
    
    // Ant state
    const antState = {
        u: 0, // position along strip (0 to 2PI * 2 for full loop on mobius)
        v: 0, // position across width (-1 to 1)
        legs: [], // array of leg objects to animate
        trailPoints: [] // history of positions
    };

    init();
    animate();

    function init() {
        // 1. SCENE SETUP
        const container = document.createElement('div');
        document.body.appendChild(container);

        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050510, 0.02);

        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(12, 10, 18);

        renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ReinhardToneMapping;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        // 2. CONTROLS
        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxDistance = 50;

        // 3. LIGHTING
        const ambientLight = new THREE.AmbientLight(0x404040, 2); 
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 2);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);

        // Accent Light (matches theme)
        const pointLight = new THREE.PointLight(PARAMS.themeColor, 5, 50);
        pointLight.position.set(-5, 5, -5);
        scene.add(pointLight);

        // 4. ENVIRONMENT
        createStarfield();
        createFloor();

        // 5. OBJECTS
        createMobiusStrip();
        createAnt();
        createTrail();

        // 6. POST-PROCESSING (Bloom)
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = PARAMS.bloomThreshold;
        bloomPass.strength = PARAMS.bloomStrength;
        bloomPass.radius = PARAMS.bloomRadius;

        composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // 7. GUI
        setupGUI();
        
        // Remove loader
        document.getElementById('loader').style.opacity = 0;
        setTimeout(() => document.getElementById('loader').remove(), 500);

        window.addEventListener('resize', onWindowResize);
    }

    // --- PROCEDURAL GEOMETRY GENERATORS ---

    function getMobiusPoint(u, v, target) {
        // Parametric Mobius Formula
        // u: 0 to 2PI (around the ring)
        // v: -1 to 1 (width)
        // twist factor: controls how many half-twists
        
        const R = PARAMS.radius;
        const w = PARAMS.width / 2; // half-width
        
        // Handle twist accumulation
        // Multiply u by twists/2 inside the cosine/sine for the twist mechanism
        const alpha = (PARAMS.twists * u) / 2;

        const x = (R + w * v * Math.cos(alpha)) * Math.cos(u);
        const y = (R + w * v * Math.cos(alpha)) * Math.sin(u);
        const z = w * v * Math.sin(alpha);

        // Rotate to lay flat on XZ plane generally, but with twist
        // Swapping Y and Z, or just rotate vector
        target.set(x, z, y); 
    }

    function createMobiusStrip() {
        if (mobiusMesh) {
            mobiusMesh.geometry.dispose();
            scene.remove(mobiusMesh);
        }

        const geometry = new THREE.BufferGeometry();
        const indices = [];
        const vertices = [];
        const normals = [];
        const colors = [];
        const uvs = [];

        const color1 = new THREE.Color(0x001133); // Dark Blue
        const color2 = new THREE.Color(PARAMS.themeColor); // Cyan/Theme

        const uSeg = PARAMS.segments;
        const vSeg = PARAMS.widthSegments;

        // Generate vertices
        for (let i = 0; i <= uSeg; i++) {
            const u = (i / uSeg) * Math.PI * 2;
            
            for (let j = 0; j <= vSeg; j++) {
                const v = (j / vSeg) * 2 - 1; // -1 to 1

                const p = new THREE.Vector3();
                getMobiusPoint(u, v, p);
                vertices.push(p.x, p.y, p.z);

                // UVs
                uvs.push(i / uSeg, j / vSeg);

                // Vertex Colors (Gradient along U)
                const mixedColor = color1.clone().lerp(color2, 0.5 + 0.5 * Math.sin(u * 2));
                colors.push(mixedColor.r, mixedColor.g, mixedColor.b);
            }
        }

        // Generate indices
        for (let i = 0; i < uSeg; i++) {
            for (let j = 0; j < vSeg; j++) {
                const a = i * (vSeg + 1) + j;
                const b = (i + 1) * (vSeg + 1) + j;
                const c = (i + 1) * (vSeg + 1) + (j + 1);
                const d = i * (vSeg + 1) + (j + 1);

                indices.push(a, b, d);
                indices.push(b, c, d);
            }
        }

        geometry.setIndex(indices);
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
        geometry.setAttribute('normal', new THREE.Float32BufferAttribute(vertices, 3)); // Placeholder, recomputed below
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
        
        geometry.computeVertexNormals();

        // Material
        const material = new THREE.MeshPhysicalMaterial({
            vertexColors: true,
            metalness: 0.3,
            roughness: 0.2,
            clearcoat: 1.0,
            clearcoatRoughness: 0.1,
            side: THREE.DoubleSide,
            wireframe: PARAMS.showWireframe
        });

        mobiusMesh = new THREE.Mesh(geometry, material);
        mobiusMesh.castShadow = true;
        mobiusMesh.receiveShadow = true;
        scene.add(mobiusMesh);
    }

    // --- ANT CREATION & ANIMATION ---

    function createAnt() {
        const antGroup = new THREE.Group();
        
        const bodyMat = new THREE.MeshStandardMaterial({ 
            color: 0x111111, 
            roughness: 0.4, 
            metalness: 0.8 
        });

        // 1. Body Parts
        const abdomen = new THREE.Mesh(new THREE.SphereGeometry(0.35, 16, 16), bodyMat);
        abdomen.scale.set(1, 1, 1.5);
        abdomen.position.z = -0.4;
        
        const thorax = new THREE.Mesh(new THREE.SphereGeometry(0.25, 16, 16), bodyMat);
        thorax.position.z = 0.1;

        const head = new THREE.Mesh(new THREE.SphereGeometry(0.2, 16, 16), bodyMat);
        head.position.z = 0.5;

        // Eyes
        const eyeMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const leftEye = new THREE.Mesh(new THREE.SphereGeometry(0.05), eyeMat);
        leftEye.position.set(0.12, 0.1, 0.6);
        const rightEye = leftEye.clone();
        rightEye.position.set(-0.12, 0.1, 0.6);
        antGroup.add(leftEye, rightEye);

        antGroup.add(abdomen, thorax, head);

        // 2. Legs (Procedural)
        // 3 pairs attached to thorax
        antState.legs = [];
        const legPositions = [0.15, 0.0, -0.15]; // Relative Z on thorax
        
        for(let i=0; i<3; i++) {
            // Left and Right legs
            createLeg(antGroup, thorax, legPositions[i], 1, i);  // Left
            createLeg(antGroup, thorax, legPositions[i], -1, i); // Right
        }

        antMesh = antGroup;
        scene.add(antMesh);
    }

    function createLeg(parentGroup, parentBody, zOffset, side, index) {
        // Simple 2-segment leg
        const legGroup = new THREE.Group();
        // Pivot point at thorax
        legGroup.position.set(side * 0.2, 0, zOffset + 0.1); 
        
        // Upper leg
        const upperLegGeo = new THREE.CylinderGeometry(0.03, 0.03, 0.4);
        upperLegGeo.rotateZ(Math.PI / 2);
        upperLegGeo.translate(0.2, 0, 0); // Shift so pivot is at start
        const upperLeg = new THREE.Mesh(upperLegGeo, parentBody.material);
        
        // Lower leg
        const lowerLegGeo = new THREE.CylinderGeometry(0.02, 0.01, 0.5);
        lowerLegGeo.rotateZ(Math.PI / 2);
        lowerLegGeo.translate(0.25, 0, 0);
        const lowerLeg = new THREE.Mesh(lowerLegGeo, parentBody.material);
        lowerLeg.position.x = 0.4; // Attach to end of upper leg
        lowerLeg.rotation.z = -Math.PI / 2; // Initial bend (downwards)

        upperLeg.add(lowerLeg);
        legGroup.add(upperLeg);
        parentGroup.add(legGroup);

        // Initial pose
        legGroup.rotation.z = side * (Math.PI / 4); // Lift slightly
        legGroup.rotation.y = side * ((index - 1) * 0.5); // Spread legs

        // Save reference for animation
        antState.legs.push({
            group: legGroup,
            upper: upperLeg,
            lower: lowerLeg,
            side: side, // 1 or -1
            index: index, // 0, 1, 2
            baseRotZ: legGroup.rotation.z,
            baseRotY: legGroup.rotation.y
        });
    }

    function updateAnt(delta) {
        if (!antMesh) return;

        const speed = PARAMS.antSpeed;
        antState.u += speed * delta;
        
        // --- 1. Position & Orientation on Strip ---
        const u = antState.u;
        const v = antState.v;

        // Calculate Position (P)
        const pos = new THREE.Vector3();
        getMobiusPoint(u, v, pos);
        antMesh.position.copy(pos);

        // Calculate Tangent (Forward vector)
        const nextPos = new THREE.Vector3();
        getMobiusPoint(u + 0.01, v, nextPos);
        const tangent = new THREE.Vector3().subVectors(nextPos, pos).normalize();

        // Calculate Normal (Up vector)
        // Approximate by taking a point slightly offset in width (v)
        const sidePos = new THREE.Vector3();
        getMobiusPoint(u, v + 0.1, sidePos);
        const bitangent = new THREE.Vector3().subVectors(sidePos, pos).normalize();
        const normal = new THREE.Vector3().crossVectors(tangent, bitangent).normalize();
        
        // If twist makes normal flip, we might need check. 
        // But for visual continuity on Mobius, math.cross usually handles it.
        
        // Create Rotation Matrix
        const dummy = new THREE.Object3D();
        dummy.position.copy(pos);
        dummy.up.copy(normal);
        dummy.lookAt(nextPos);
        antMesh.quaternion.copy(dummy.quaternion);

        // --- 2. Leg Animation (Tripod Gait) ---
        // Groups: (LeftFront, RightMid, LeftBack) vs (RightFront, LeftMid, RightBack)
        const walkCycle = time * speed * 10;
        
        antState.legs.forEach(leg => {
            const isGroupA = (leg.side === 1 && leg.index % 2 === 0) || (leg.side === -1 && leg.index % 2 !== 0);
            const phase = isGroupA ? 0 : Math.PI;
            
            // Lift leg (Z rotation relative to body)
            const lift = Math.max(0, Math.sin(walkCycle + phase));
            leg.group.rotation.z = leg.baseRotZ + (leg.side * lift * 0.5);

            // Move leg forward/back (Y rotation relative to body)
            const swing = Math.cos(walkCycle + phase);
            leg.group.rotation.y = leg.baseRotY + (swing * 0.3);
        });

        // Slight body wobble
        antMesh.position.addScaledVector(normal, Math.abs(Math.sin(walkCycle*2)) * 0.05);

        // --- 3. Trail Update ---
        updateTrail(pos);
    }

    // --- TRAIL SYSTEM ---
    
    function createTrail() {
        // Start with empty geometry
        const geometry = new THREE.BufferGeometry();
        // Pre-allocate buffer for performance (e.g., 500 points)
        const maxPoints = 500;
        const positions = new Float32Array(maxPoints * 3);
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setDrawRange(0, 0);

        const material = new THREE.LineBasicMaterial({ 
            color: PARAMS.themeColor, 
            linewidth: 2 // Note: linewidth only works on WebGL1 usually, will be 1px on WebGL2
        });

        trailLine = new THREE.Line(geometry, material);
        scene.add(trailLine);
    }

    function updateTrail(newPos) {
        // Add new point
        antState.trailPoints.push(newPos.clone());
        
        // Limit length
        if (antState.trailPoints.length > 500) {
            antState.trailPoints.shift();
        }

        // We could use CatmullRomCurve3 here to smooth, but just updating buffer is faster for real-time
        // To make it smooth visually, we just need high point density (which we have from 60fps)
        
        const positions = trailLine.geometry.attributes.position.array;
        
        for (let i = 0; i < antState.trailPoints.length; i++) {
            positions[i * 3] = antState.trailPoints[i].x;
            positions[i * 3 + 1] = antState.trailPoints[i].y;
            positions[i * 3 + 2] = antState.trailPoints[i].z;
        }

        trailLine.geometry.attributes.position.needsUpdate = true;
        trailLine.geometry.setDrawRange(0, antState.trailPoints.length);
        
        // Update glow color to match theme
        trailLine.material.color.set(PARAMS.themeColor);
    }

    // --- ENVIRONMENT HELPERS ---

    function createStarfield() {
        const geom = new THREE.BufferGeometry();
        const vertices = [];
        for(let i=0; i<2000; i++) {
            vertices.push(
                (Math.random() - 0.5) * 200,
                (Math.random() - 0.5) * 200,
                (Math.random() - 0.5) * 200
            );
        }
        geom.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
        const mat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.2, transparent: true, opacity: 0.8 });
        const stars = new THREE.Points(geom, mat);
        scene.add(stars);
    }

    function createFloor() {
        const geom = new THREE.PlaneGeometry(200, 200);
        const mat = new THREE.ShadowMaterial({ opacity: 0.3 });
        const floor = new THREE.Mesh(geom, mat);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -8;
        floor.receiveShadow = true;
        scene.add(floor);

        // Add a grid for visual reference
        const grid = new THREE.GridHelper(200, 50, 0x333333, 0x111111);
        grid.position.y = -8.01;
        scene.add(grid);
    }

    // --- UI SETUP ---

    function setupGUI() {
        const gui = new GUI({ title: 'Mobius Controls' });
        
        const folderGeo = gui.addFolder('Geometry');
        folderGeo.add(PARAMS, 'twists', 0, 5, 0.1).name('Twists').onChange(createMobiusStrip);
        folderGeo.add(PARAMS, 'width', 0.1, 5).name('Width').onChange(createMobiusStrip);
        folderGeo.add(PARAMS, 'radius', 1, 10).name('Radius').onChange(createMobiusStrip);
        folderGeo.add(PARAMS, 'showWireframe').name('Wireframe').onChange(createMobiusStrip);

        const folderAnt = gui.addFolder('The Ant');
        folderAnt.add(PARAMS, 'antSpeed', 0, 5).name('Speed');

        const folderVis = gui.addFolder('Visuals');
        folderVis.addColor(PARAMS, 'themeColor').name('Theme Color').onChange(() => {
            createMobiusStrip();
            scene.children.forEach(c => {
                if(c.isPointLight) c.color.set(PARAMS.themeColor);
            });
        });
        folderVis.add(PARAMS, 'bloomStrength', 0, 3).onChange(v => bloomPass.strength = v);
        
        // Reset Ant button
        const obj = { reset: () => {
            antState.u = 0;
            antState.trailPoints = [];
        }};
        folderAnt.add(obj, 'reset').name('Reset Position');
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
    }

    // --- MAIN LOOP ---

    function animate() {
        requestAnimationFrame(animate);

        const delta = clock.getDelta();
        time += delta;

        updateAnt(delta);
        controls.update();

        // Render with post-processing
        composer.render();
    }
</script>
</body>
</html>
